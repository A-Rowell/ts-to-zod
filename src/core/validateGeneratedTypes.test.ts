import { validateGeneratedTypes } from "./validateGeneratedTypes";

describe("validateGeneratedTypes", () => {
  it("should return no error if the types match", () => {
    const sourceText = `
      export type MyNumber = number;
    `;

    const getZodSchemasFile = () => `// Generated by ts-to-zod
    import { z } from "zod";
    export const myNumberSchema = z.number();
    `;

    const getIntegrationTestFile = (
      typesImportPath: string,
      zodSchemasImportPath: string
    ) => `// Generated by ts-to-zod
      import { z } from "zod";
      
      import * as spec from "${typesImportPath}";
      import * as generated from "${zodSchemasImportPath}";
      
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      function expectType<T>(_: T) {
        /* noop */
      }

      export type myNumberSchemaInferredType = z.infer<typeof generated.myNumberSchema>;

      expectType<myNumberSchemaInferredType>({} as spec.MyNumber);
      expectType<spec.MyNumber>({} as myNumberSchemaInferredType);
  `;

    const errors = validateGeneratedTypes({
      sourceText,
      getZodSchemasFile,
      getIntegrationTestFile,
    });

    expect(errors).toEqual([]);
  });

  it("should return an error if the types doesn't match", () => {
    const sourceText = `
      export type MyNumber = number;
    `;

    const getZodSchemasFile = () => `// Generated by ts-to-zod
    import { z } from "zod";
    export const myStringSchema = z.string();
    `;

    const getIntegrationTestFile = (
      typesImportPath: string,
      zodSchemasImportPath: string
    ) => `// Generated by ts-to-zod
      import { z } from "zod";
      
      import * as spec from "${typesImportPath}";
      import * as generated from "${zodSchemasImportPath}";
      
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      function expectType<T>(_: T) {
        /* noop */
      }

      export type myStringSchemaInferredType = z.infer<typeof generated.myStringSchema>;

      expectType<myStringSchemaInferredType>({} as spec.MyNumber);
      expectType<spec.MyNumber>({} as myStringSchemaInferredType);
  `;

    const errors = validateGeneratedTypes({
      sourceText,
      getZodSchemasFile,
      getIntegrationTestFile,
    });

    expect(errors).toMatchInlineSnapshot(`
      Array [
        "'MyNumber' is not compatible with 'myStringSchema':
      Argument of type 'number' is not assignable to parameter of type 'string'.",
        "'myStringSchema' is not compatible with 'MyNumber':
      Argument of type 'string' is not assignable to parameter of type 'number'.",
      ]
    `);
  });
});
